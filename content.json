[{"title":"Android FrameWork SystemUI学习心得","date":"2017-04-19T12:14:12.000Z","path":"2017/04/19/Android-FrameWork-SystemUI学习心得/","text":"笔记记录（学习自网络及深入理解android第三版）-Binder是android系统提供的一种IPC机制，由于android基于Linux内核的因此，除了Binder以外，还存在其他的IPC机制。例如socket等 SystemUI 提供了PowerUI和RingtonePlayer两个服务，前者负责监控系统的剩余电量，后者则依托AudioService来向其他程序提供播放铃声的功能 当核心系统服务启动完成后ServiceThread会通过调用ActivityManagerServices.systemReady()方法通知AMS系统已经就绪，这个systemReady（）拥有一个名为goingCallback的Runnable实例作为参数，当AMS完成时对systemReady（）的处理后将会回调这一runnable的run方法。而在这一run方法中可以找到SystemUI的身影在startSystemUI方法中1234567static final void startSystemUi(Content,content)&#123; Intent intent = new Intent(); //设置SystemUIservice作为启动目标 intent.setCompoent(new ComponentName(&quot;com.android.systemui&quot;,&quot;com.android.systemui.SystemService&quot;)); context.startServiceAsUser(intent,UserHandle.OWNER); &#125; notification和statusBarNotification存储了需要显示在状态栏的通知区中的通知信息，前者存储了一个binder表示的通知发送者的Id列表，而notification则存储了通知列表。二者通过索引号一一对应 状态栏信息有以下几种 通知信息：时间信息：电量信息：信号信息：系统状态图标区： 定义了两套导航栏控件树，以水平方式布局的@id/rot0,以及垂直方向进行布局的@id/roy90 创建navigationbar在start方法中完成baseStatusBar.start()方法会调用PhoneStatusBar.makeStatusBarView(); prepareNagivationBarView()负责为NagivationBarView中的虚拟按键设置用于响应用户触摸事件的监听器OnclickListener或OnTouchListener，这些监听器将用来产生并向输入系统注射虚拟的按键事件123456789101112LayoutParams.MATCH_PARENT,LayoutParams.MATCH_PARENT,类型 LayoutParams.TYPE_NAVIGATION_BAR不接受按键事件 LayoutParams.FLAG_TOUCHABLE_WHEN_WAKING不阻挡位于其下的 LayoutParams.FLAG_NOT_FOCUSABLE窗口获取点击事件 LayoutParams.FLAG_NOT_TOUCH_MODAL//当用户在其他窗口上点击时可以收到通知LayoutParams.FLAG_WATCH_OUTSIDE_TOUCHLayoutParams.FLAG_SPLIT_TOUCH导航栏的宽高取值来自位于frameworks/base/core/res/res/values/dimens.xml中的navigation_bar_height以及navigation_bar_height_landscape两个资源keybuttonView继承自ImageView，它对ImageView的扩展就是根据派发给他的触摸事件转化为按键事件 代码修改过程中遇到的问题及心得体会：- 1：修改记录 首先修改这个PhoneStatusBar.java 文件 我在NavigationBarView中添加了一个按钮为外界暴露了一个方法，返回值是这个按钮 之后在PhoneStatus.java中设置了一个监听事件mHideBarClickListener 之后设置了一个点击事件 在这个点击事件中调用了 removeBar()方法用来移除底部导航栏 状态栏为mStatusBarView这个View 如果设置了mStatusBarView.setVisibility 为GONE，那么状态栏就为不可见状态 显示 导航栏 在这个文件夹下frameworks/base/policy/src/com/android/internal/policy/impl PhoneWindowManager.java这个文件中有主界面的手势控制 其中onSwipeFromBottom 表示监听底部的手势滑动 onSwipeFromRight表示从右侧滑动 查看这个文件可以看到其中调用了 addBar()这个方法 我可以在addbar这个方法中设置mStatusBarView的Visibility 为VISIBILE 就可以做到 状态栏和导航栏的 同步显示和隐藏12345addBar()&#123; //这个方法中调用了这个方法 addBarInside();&#125;； 主要还是说一下addbar这个方法中的参数 第一个是mBarIsAdd 表示底部导航栏是否被添加 第二个是showNav 由系统服务调用hasNavigationBar 表示 是否需要这个navigationbar 2：遇到的问题 对源码不了解 在刚开始修改的时候 并不知道源码中提供了两个 公共方法 removeBar 和 addBar 于是 就先添加了一个按钮，设置了一个监听事件 直接调用了mWindowManager的removeView方法 来移除这个View mNavigationBarView这样子 不会将mBarIsadd设置为false 不懂情况将代码乱修改 由于没有参考资料或者教程，自己摸索过程中 将顶部状态栏修改，在隐藏顶部状态栏时，在这个addNavigationBar()方法中看到了一个mWindowManager.addView()方法，以为这个就是添加顶部导航栏的方法，认为删除这个方法就可以控制顶部导航栏的增加或者删除，删除了这个方法将代码写入System中发现了一直重新启动的状态，最后强行将新的UI写入进去才得以恢复。 3：心得因为这是第一次查看源码，还是framework级别的源码。看到了google开发人员的代码的规范性非常强，注释也非常多，大大提高了源码的可阅读性，而且 模块化变成，面向接口编程等一系列编程思想也在源码中有非常好的体现，举个简单的例子，我之前写代码 实例化一个view时直接用findViewById方法来获得一个View的实例但是在源码中却是 写了一个方法比如123public View getButton()&#123; return findViewById(R.Id.newButton);&#125; 这样一个简单的做法其实并不省事，但是却大大提高了程序的可阅读性，也减少了许多变量，虽然代码增加了 但是程序看起来简洁了许多，这是我今后写代码过程中需要学习的地方，而且模块化编程，大大降低了各个模块间的耦合度，提高了代码的可维护性 我是华文彩云","categories":[],"tags":[]},{"title":"Hello World","date":"2017-04-19T11:54:10.960Z","path":"2017/04/19/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]